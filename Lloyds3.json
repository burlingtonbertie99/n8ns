{
  "name": "Lloyds3",
  "nodes": [
    {
      "parameters": {
        "inputSource": "passthrough"
      },
      "id": "06ec188e-4d67-49a4-a2a3-bdcc69f28d79",
      "typeVersion": 1.1,
      "name": "Start",
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "position": [
        -416,
        144
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.hubapi.com/crm/v3/objects/tickets/search",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "hubspotAppToken",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "{\n  \"filterGroups\": [\n    {\n      \"filters\": [\n        {\n          \"propertyName\": \"associations.company\",\n          \"operator\": \"EQ\",\n          \"value\": 62873106\n        },\n        {\n          \"propertyName\": \"createdate\",\n          \"operator\": \"GTE\",\n          \"value\": \"2025-06-01T00:00:00Z\"\n        }\n      ]\n    }\n  ],\n  \"sorts\": [\n    { \"propertyName\": \"createdate\", \"direction\": \"ASCENDING\" }\n  ],\n  \"properties\": [\n    \"subject\",    \n    \"createdate\",    \n    \"closed_date\",\n    \"time_to_first_agent_reply\",\n    \"hs_time_to_close\",\n    \"hs_pipeline_stage\"\n  ],\n  \"limit\": 100\n}\n",
        "options": {
          "allowUnauthorizedCerts": true
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -192,
        0
      ],
      "id": "147550a0-1b35-4bb6-b53a-701654cbd051",
      "name": "HTTP Request1",
      "credentials": {
        "hubspotAppToken": {
          "id": "VlcyEHh7eyaNKHpu",
          "name": "HubSpot App Token account"
        }
      }
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.hubapi.com/crm/v3/objects/tickets/search",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "hubspotAppToken",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "{\n  \"filterGroups\": [\n    {\n      \"filters\": [\n        {\n          \"propertyName\": \"associations.company\",\n          \"operator\": \"EQ\",\n          \"value\": 62873106\n        },\n        {\n          \"propertyName\": \"hs_pipeline_stage\",\n          \"operator\": \"NEQ\",\n          \"value\": 4\n        }\n      ]\n    }\n  ],\n  \"sorts\": [\n    { \"propertyName\": \"createdate\", \"direction\": \"ASCENDING\" }\n  ],\n  \"properties\": [\n    \"subject\",    \n    \"createdate\", \n    \"closed_date\",\n    \"time_to_first_agent_reply\",\n    \"hs_time_to_close\",\n    \"hs_pipeline_stage\"\n  ],\n  \"limit\": 100\n}\n",
        "options": {
          "allowUnauthorizedCerts": true
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -192,
        240
      ],
      "id": "809bc531-964d-40f9-ac7e-4bcf8e3e9192",
      "name": "HTTP Request",
      "credentials": {
        "hubspotAppToken": {
          "id": "VlcyEHh7eyaNKHpu",
          "name": "HubSpot App Token account"
        }
      }
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        32,
        48
      ],
      "id": "2a989c59-520d-43e7-8508-d5a588cf9434",
      "name": "Merge"
    },
    {
      "parameters": {
        "operation": "xlsx",
        "options": {}
      },
      "type": "n8n-nodes-base.convertToFile",
      "typeVersion": 1.1,
      "position": [
        864,
        48
      ],
      "id": "bf509a9d-2742-4ae2-ab7e-a9ed9a87c674",
      "name": "Convert to File"
    },
    {
      "parameters": {
        "fieldToSplitOut": "results",
        "options": {}
      },
      "type": "n8n-nodes-base.splitOut",
      "typeVersion": 1,
      "position": [
        704,
        48
      ],
      "id": "0e58ae0d-d561-4537-8161-6e102b7d35f6",
      "name": "Split Out"
    },
    {
      "parameters": {
        "jsCode": "// n8n Function node â€” SLA calculation tuned for your sample JSON\n// - Handles input shapes like: [{ total: X, results: [ { id, properties: {...}, createdAt, updatedAt } ] }]\n// - Produces one output item per ticket with slaStatus and breachReasons\n\n// === CONFIG ===\nconst DEFAULT_SLA_FIRST_RESPONSE_HOURS = 80; // change if needed\nconst DEFAULT_SLA_RESOLUTION_HOURS = 240;   // change if needed\n\n// If true, and hs_time_to_first_agent_reply is missing, this will (optionally)\n// use the ticket.updatedAt/hs_lastmodifieddate as a fallback approximation for\n// \"first response\". Set to true if your portal's lastmodified reliably means agent reply.\nconst FALLBACK_USE_LAST_MODIFIED_AS_FIRST_RESPONSE = true;\n\n// === helpers ===\nfunction parseTimestamp(v) {\n  if (v === undefined || v === null || v === '') return null;\n  if (typeof v === 'number') {\n    // heuristic: large numbers are ms\n    if (v > 1e11) return new Date(v);\n    return new Date(v * 1000);\n  }\n  if (typeof v === 'string') {\n    // numeric string?\n    if (/^\\d+$/.test(v)) {\n      return parseTimestamp(Number(v));\n    }\n    const d = new Date(v);\n    if (!isNaN(d.getTime())) return d;\n    return null;\n  }\n  return null;\n}\nfunction msToHours(ms) {\n  return ms == null ? null : ms / (1000 * 60 * 60);\n}\nfunction round4(n) {\n  return n == null ? null : Number(n.toFixed(4));\n}\nfunction getProp(o, key) {\n  if (!o) return undefined;\n  if (o.properties && o.properties[key] !== undefined) return o.properties[key];\n  if (o[key] !== undefined) return o[key];\n  return undefined;\n}\n\n// === normalize input (support multiple possible paste shapes) ===\nlet rawTickets = [];\nconst firstInput = items[0] && items[0].json;\n\nif (items.length === 1) {\n  // cases we expect from your paste:\n  // 1) items[0].json is an array whose first element has .results => [ { total, results: [...] } ]\n  // 2) items[0].json is an object with .results array\n  // 3) items[0].json is directly an array of ticket objects\n  if (Array.isArray(firstInput) && firstInput.length > 0 && Array.isArray(firstInput[0].results)) {\n    rawTickets = firstInput[0].results;\n  } else if (firstInput && Array.isArray(firstInput.results)) {\n    rawTickets = firstInput.results;\n  } else if (Array.isArray(firstInput)) {\n    rawTickets = firstInput;\n  } else {\n    // fallback: treat each incoming item as a ticket\n    rawTickets = items.map(i => i.json);\n  }\n} else {\n  rawTickets = items.map(i => i.json);\n}\n\n// === process ===\nconst output = rawTickets.map(ticket => {\n  // IDs & subject\n  const ticketId = ticket.id ?? ticket.properties?.hs_object_id ?? ticket.properties?.hs_object_id ?? null;\n  const subject = getProp(ticket, 'subject') ?? ticket.title ?? null;\n\n  // created / closed\n  const createdRaw = getProp(ticket, 'createdate') ?? ticket.createdAt ?? ticket.created_at ?? ticket.created;\n  const createdAt = parseTimestamp(createdRaw);\n\n  const closedRaw = getProp(ticket, 'closed_date') ?? ticket.closedAt ?? ticket.closed_at ?? ticket.closed;\n  const closedAt = parseTimestamp(closedRaw);\n\n  // built-in ms fields (HubSpot sometimes gives ms, sometimes numeric-string)\n  const rawFirstMs = getProp(ticket, 'hs_time_to_first_agent_reply') ?? getProp(ticket, 'hs_time_to_first_reply') ?? ticket.hs_time_to_first_agent_reply;\n  const rawCloseMs = getProp(ticket, 'hs_time_to_close') ?? ticket.hs_time_to_close;\n\n  const firstMs = rawFirstMs ? Number(rawFirstMs) : null;\n  const closeMs = rawCloseMs ? Number(rawCloseMs) : null;\n\n  // compute durations (hours)\n  let timeToFirstHours = firstMs ? msToHours(firstMs) : null;\n  let timeToCloseHours = closeMs ? msToHours(closeMs) : null;\n\n  // fallback: compute timeToFirst using last modified / updated if enabled\n  if (!timeToFirstHours && FALLBACK_USE_LAST_MODIFIED_AS_FIRST_RESPONSE && createdAt) {\n    const lastModRaw = getProp(ticket, 'hs_lastmodifieddate') ?? ticket.updatedAt ?? ticket.updated_at;\n    const lastMod = parseTimestamp(lastModRaw);\n    if (lastMod) {\n      timeToFirstHours = msToHours(lastMod.getTime() - createdAt.getTime());\n    }\n  }\n\n  // fallback: compute timeToClose from createdAt/closedAt when hs_time_to_close is missing\n  if (timeToCloseHours == null && createdAt && closedAt) {\n    timeToCloseHours = msToHours(closedAt.getTime() - createdAt.getTime());\n  }\n\n  // per-ticket SLA override (optional): ticket.sla = { firstResponseHours, resolutionHours }\n  const SLA_FIRST_HOURS = (ticket.sla && ticket.sla.firstResponseHours) ? Number(ticket.sla.firstResponseHours) : DEFAULT_SLA_FIRST_RESPONSE_HOURS;\n  const SLA_RES_HOURS = (ticket.sla && ticket.sla.resolutionHours) ? Number(ticket.sla.resolutionHours) : DEFAULT_SLA_RESOLUTION_HOURS;\n\n  const firstResponseMet = (timeToFirstHours != null) ? (timeToFirstHours <= SLA_FIRST_HOURS) : false;\n  const resolutionMet = (timeToCloseHours != null) ? (timeToCloseHours <= SLA_RES_HOURS) : false;\n\n  // reasons\n  const breachReasons = [];\n  if (timeToFirstHours == null) breachReasons.push('missing_first_response_time');\n  else if (!firstResponseMet) breachReasons.push('first_response_breached');\n\n  if (timeToCloseHours == null) breachReasons.push('missing_resolution_time');\n  else if (!resolutionMet) breachReasons.push('resolution_breached');\n\n  const slaStatus = breachReasons.length === 0 ? 'Met' : 'Breached';\n\n  return {\n    json: {\n      ticketId,\n      subject,\n      createdAt: createdAt ? createdAt.toISOString() : null,\n      closedAt: closedAt ? closedAt.toISOString() : null,\n      timeToFirstHours: round4(timeToFirstHours),\n      timeToFirstReadable: timeToFirstHours == null ? null : `${Math.floor(timeToFirstHours)}h ${Math.round((timeToFirstHours%1)*60)}m`,\n      timeToCloseHours: round4(timeToCloseHours),\n      timeToCloseReadable: timeToCloseHours == null ? null : `${Math.floor(timeToCloseHours)}h ${Math.round((timeToCloseHours%1)*60)}m`,\n      firstResponseMet,\n      resolutionMet,\n      SLA_firstHours: SLA_FIRST_HOURS,\n      SLA_resolutionHours: SLA_RES_HOURS,\n      breachReasons,\n      slaStatus,\n      raw: ticket // include raw ticket for debugging if you need it\n    }\n  };\n});\n\nreturn output;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        32,
        288
      ],
      "id": "914671b8-7cca-46b3-bdd7-7237966657e3",
      "name": "Code in JavaScript",
      "disabled": true
    },
    {
      "parameters": {
        "jsCode": "// n8n Function node\n// Merges multiple JSON inputs and deduplicates by \"id\"\n\nlet merged = [];\n\n// Collect all results arrays from inputs\nfor (const item of items) {\n  if (item.json.results && Array.isArray(item.json.results)) {\n    merged.push(...item.json.results);\n  }\n}\n\n// Deduplicate by \"id\"\nconst seen = new Set();\nconst deduped = merged.filter(entry => {\n  if (seen.has(entry.id)) {\n    return false;\n  }\n  seen.add(entry.id);\n  return true;\n});\n\n// Return single combined output\nreturn [\n  {\n    json: {\n      total: deduped.length,\n      results: deduped\n    }\n  }\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        256,
        48
      ],
      "id": "42034485-6dfd-446a-b3ec-e56e03ff41f7",
      "name": "SuperMerge"
    },
    {
      "parameters": {
        "jsCode": "// n8n Function node â€” SLA calculation using $input (avoids 'items' linter errors)\n// Paste into a Function node. Returns one output item per ticket: { json: { ... } }\n\n// === CONFIG ===\nconst DEFAULT_SLA_FIRST_RESPONSE_HOURS = 48; // change if needed\nconst DEFAULT_SLA_RESOLUTION_HOURS = 1000;   // change if needed\n\n// If true, and hs_time_to_first_agent_reply is missing, use hs_lastmodifieddate/updatedAt as a fallback\nconst FALLBACK_USE_LAST_MODIFIED_AS_FIRST_RESPONSE = true;\n\n// === helpers ===\nfunction parseTimestamp(v) {\n  if (v === undefined || v === null || v === '') return null;\n  if (typeof v === 'number') {\n    // heuristic: large numbers are ms\n    if (v > 1e11) return new Date(v);\n    return new Date(v * 1000);\n  }\n  if (typeof v === 'string') {\n    if (/^\\d+$/.test(v)) return parseTimestamp(Number(v));\n    const d = new Date(v);\n    if (!isNaN(d.getTime())) return d;\n    return null;\n  }\n  return null;\n}\nfunction msToHours(ms) {\n  return ms == null ? null : ms / (1000 * 60 * 60);\n}\nfunction round4(n) {\n  return n == null ? null : Number(n.toFixed(4));\n}\nfunction getProp(o, key) {\n  if (!o) return undefined;\n  if (o.properties && o.properties[key] !== undefined) return o.properties[key];\n  if (o[key] !== undefined) return o[key];\n  return undefined;\n}\n\n// Use n8n $input helper to get incoming items (linter-friendly)\nconst incoming = $input.all(); // array of { json:, binary: }\n\n// === normalize input (support multiple possible paste shapes) ===\nlet rawTickets = [];\nif (incoming.length === 1) {\n  const firstJson = incoming[0].json;\n  if (Array.isArray(firstJson) && firstJson.length > 0 && Array.isArray(firstJson[0].results)) {\n    // shape: [ { total, results: [...] } ]\n    rawTickets = firstJson[0].results;\n  } else if (firstJson && Array.isArray(firstJson.results)) {\n    // shape: { total, results: [...] }\n    rawTickets = firstJson.results;\n  } else if (Array.isArray(firstJson)) {\n    // shape: [ { id, properties... }, ... ]\n    rawTickets = firstJson;\n  } else {\n    // fallback: treat each incoming item as a ticket (single item per input)\n    rawTickets = incoming.map(i => i.json);\n  }\n} else {\n  rawTickets = incoming.map(i => i.json);\n}\n\n// === process tickets ===\nconst output = rawTickets.map(ticket => {\n  // ids & subject\n  const ticketId = ticket.id ?? ticket.properties?.hs_object_id ?? ticket.properties?.hs_object_id ?? null;\n  const subject = getProp(ticket, 'subject') ?? ticket.title ?? null;\n\n  // created / closed\n  const createdRaw = getProp(ticket, 'createdate') ?? ticket.createdAt ?? ticket.created_at ?? ticket.created;\n  const createdAt = parseTimestamp(createdRaw);\n\n  const closedRaw = getProp(ticket, 'closed_date') ?? ticket.closedAt ?? ticket.closed_at ?? ticket.closed;\n  const closedAt = parseTimestamp(closedRaw);\n\n  // built-in ms fields (HubSpot sometimes gives ms, sometimes numeric-string)\n  const rawFirstMs = getProp(ticket, 'time_to_first_agent_reply') ?? getProp(ticket, 'time_to_first_reply') ?? ticket.time_to_first_agent_reply;\n  const rawCloseMs = getProp(ticket, 'hs_time_to_close') ?? ticket.hs_time_to_close;\n // console.log('DEBUG 000');\n // console.log(rawFirstMs);\n // console.log('DEBUG 001');\n // console.log(Number(rawFirstMs));\n // console.log('DEBUG 002');\n  const firstMs = rawFirstMs ? Number(rawFirstMs) : null;\n  const closeMs = rawCloseMs ? Number(rawCloseMs) : null;\n  //console.log(firstMs);\n // console.log('DEBUG 003');\n  // compute durations (hours)\n  let timeToFirstHours = firstMs ? msToHours(firstMs) : null;\n // console.log(timeToFirstHours);\n // console.log('DEBUG END');\n  let timeToCloseHours = closeMs ? msToHours(closeMs) : null;\n\n  // fallback: compute timeToFirst using last modified / updated if enabled\n  if (!timeToFirstHours && FALLBACK_USE_LAST_MODIFIED_AS_FIRST_RESPONSE && createdAt) {\n    const lastModRaw = getProp(ticket, 'hs_lastmodifieddate') ?? ticket.updatedAt ?? ticket.updated_at;\n    const lastMod = parseTimestamp(lastModRaw);\n\n    const lastModgetTime = lastMod.getTime();\n\n    const createdAtgetTime = createdAt.getTime();\n    \n    if (lastMod) {\n      timeToFirstHours = msToHours(lastModgetTime - createdAtgetTime);\n\n  //console.log('DEBUG 000');\n     // console.log(lastMod);\n  //console.log(msToHours(lastModgetTime));\n // console.log('DEBUG 001');\n    //  console.log(createdAt);\n//  console.log(msToHours(createdAtgetTime));\n // console.log('DEBUG 002');\n\n\n      \n    }\n  }\n\n    \n\n\n  // fallback: compute timeToClose from createdAt/closedAt when hs_time_to_close is missing\n  if (timeToCloseHours == null && createdAt && closedAt) {\n    timeToCloseHours = msToHours(closedAt.getTime() - createdAt.getTime());\n  }\n\n  // per-ticket SLA override (optional): ticket.sla = { firstResponseHours, resolutionHours }\n\n  \n  //const SLA_FIRST_HOURS = (ticket.sla && ticket.sla.firstResponseHours) ? Number(ticket.sla.firstResponseHours) : DEFAULT_SLA_FIRST_RESPONSE_HOURS;\n  //const SLA_RES_HOURS = (ticket.sla && ticket.sla.resolutionHours) ? Number(ticket.sla.resolutionHours) : DEFAULT_SLA_RESOLUTION_HOURS;\n\n\n   // reasons\n  const breachReasons = [];\n  const warnings = [];\n\n\n\n  //const firstResponseMet = ((timeToFirstHours != null)) ? ((timeToFirstHours <= SLA_FIRST_HOURS)) : false;\n // const resolutionMet = (timeToCloseHours != null) ? (timeToCloseHours <= SLA_RES_HOURS) : true;\n\n \n/*  \n  if (timeToFirstHours == null) {breachReasons.push('missing_first_response_time');}\n  else if (!firstResponseMet) {\n    if(timeToFirstHours!=timeToCloseHours)  \n        breachReasons.push('first_response_breached');\n    else{warnings.push('anomolous');}\n  \n  \n  }\n*/\n  \n  //if (timeToCloseHours == null) breachReasons.push('missing_resolution_time');\n  //else if (!resolutionMet) breachReasons.push('resolution_breached');\n\n  \n\n  //if (timeToCloseHours == null) warnings.push('missing_resolution_time');\n\n  //if (!resolutionMet) warnings.push('closure_time_warning');\n\n if ( Math.trunc(timeToFirstHours)===Math.trunc(timeToCloseHours)){\n\n     //something went wrong\n     warnings.push('anomalous');\n   \n   \n   \n } else if(timeToFirstHours>DEFAULT_SLA_FIRST_RESPONSE_HOURS)\n \n {\n\n   breachReasons.push('first_response_breached');\n   \n }\n\n  if (timeToCloseHours>DEFAULT_SLA_RESOLUTION_HOURS){\n\n     warnings.push('long_closure_time');\n  }\n\n  const slaStatus = breachReasons.length === 0 ? 'Met' : 'Breached';\n\n  return {\n    json: {\n     // ticketId,\n      subject,\n    //  createdAt: createdAt ? createdAt.toISOString() : null,\n    //  closedAt: closedAt ? closedAt.toISOString() : null,\n    //  timeToFirstHours: round4(timeToFirstHours),\n      timeToFirstReadable: timeToFirstHours == null ? null : `${Math.floor(timeToFirstHours)}h ${Math.round((timeToFirstHours % 1) * 60)}m`,\n    //  timeToCloseHours: round4(timeToCloseHours),\n      timeToCloseReadable: timeToCloseHours == null ? null : `${Math.floor(timeToCloseHours)}h ${Math.round((timeToCloseHours % 1) * 60)}m`,\n   //   firstResponseMet,\n   //   resolutionMet,\n   //   SLA_firstHours: SLA_FIRST_HOURS,\n   //   SLA_resolutionHours: SLA_RES_HOURS,\n      breachReasons,\n      slaStatus,\n      warnings\n     // raw: ticket // include raw ticket for debugging if desired\n     \n    }\n  };\n});\n\n// n8n expects an array of items back\n//return {\"results\":{output} };\n//const output2 = output.map(() => {\n // json:\"results\":{});\n//});\n  \nreturn  { \"results\": output } ;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        480,
        48
      ],
      "id": "7b21db84-966f-4134-975f-2708361a1257",
      "name": "SLA_Logic"
    },
    {
      "parameters": {
        "command": "python /home/chris/src/Xl2PPT/xl2ppt.py"
      },
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [
        592,
        320
      ],
      "id": "07aa3df0-f8fb-43ef-a661-fc063fc2bf98",
      "name": "Execute Command",
      "disabled": true
    }
  ],
  "pinData": {},
  "connections": {
    "Start": {
      "main": [
        [
          {
            "node": "HTTP Request1",
            "type": "main",
            "index": 0
          },
          {
            "node": "HTTP Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 1
          },
          {
            "node": "Code in JavaScript",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request1": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge": {
      "main": [
        [
          {
            "node": "SuperMerge",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split Out": {
      "main": [
        [
          {
            "node": "Convert to File",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "SuperMerge": {
      "main": [
        [
          {
            "node": "SLA_Logic",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "SLA_Logic": {
      "main": [
        [
          {
            "node": "Split Out",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Convert to File": {
      "main": [
        []
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "7e65ce40-f973-4b26-826e-6720572e053b",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "bd7e4bf7d1cfcb300d5188e94e5c914a4b57906e9d5593274ef36edbdad59fc8"
  },
  "id": "XxN783z9K9m2ROa7",
  "tags": []
}
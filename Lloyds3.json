{
  "name": "Lloyds3",
  "nodes": [
    {
      "parameters": {
        "inputSource": "passthrough"
      },
      "id": "551f7c67-3dfb-4d02-8b02-159b5277c5b5",
      "typeVersion": 1.1,
      "name": "Start",
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "position": [
        -304,
        272
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.hubapi.com/crm/v3/objects/tickets/search",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "hubspotAppToken",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "{\n  \"filterGroups\": [\n    {\n      \"filters\": [\n        {\n          \"propertyName\": \"associations.company\",\n          \"operator\": \"EQ\",\n          \"value\": 62873106\n        },\n        {\n          \"propertyName\": \"createdate\",\n          \"operator\": \"GTE\",\n          \"value\": \"2025-06-01T00:00:00Z\"\n        }\n      ]\n    }\n  ],\n  \"sorts\": [\n    { \"propertyName\": \"createdate\", \"direction\": \"ASCENDING\" }\n  ],\n  \"properties\": [\n    \"subject\",    \n    \"createdate\",    \n    \"closed_date\",\n    \"time_to_first_agent_reply\",\n    \"time_to_close\",\n    \"hs_pipeline_stage\"\n  ],\n  \"limit\": 100\n}\n",
        "options": {
          "allowUnauthorizedCerts": true
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -80,
        128
      ],
      "id": "7a0afb21-6fcc-4d9e-b09c-cd674fa44a0f",
      "name": "HTTP Request1",
      "credentials": {
        "hubspotAppToken": {
          "id": "2yehenPyLDtzjpO1",
          "name": "HubSpot App Token account"
        }
      }
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.hubapi.com/crm/v3/objects/tickets/search",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "hubspotAppToken",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "{\n  \"filterGroups\": [\n    {\n      \"filters\": [\n        {\n          \"propertyName\": \"associations.company\",\n          \"operator\": \"EQ\",\n          \"value\": 62873106\n        },\n        {\n          \"propertyName\": \"hs_pipeline_stage\",\n          \"operator\": \"NEQ\",\n          \"value\": 4\n        }\n      ]\n    }\n  ],\n  \"sorts\": [\n    { \"propertyName\": \"createdate\", \"direction\": \"ASCENDING\" }\n  ],\n  \"properties\": [\n    \"subject\",    \n    \"createdate\", \n    \"closed_date\",\n    \"time_to_first_agent_reply\",\n    \"time_to_close\",\n    \"hs_pipeline_stage\"\n  ],\n  \"limit\": 100\n}\n",
        "options": {
          "allowUnauthorizedCerts": true
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -80,
        368
      ],
      "id": "b4bd0a7a-eb71-4af4-a9f7-e816aaa74687",
      "name": "HTTP Request",
      "credentials": {
        "hubspotAppToken": {
          "id": "2yehenPyLDtzjpO1",
          "name": "HubSpot App Token account"
        }
      }
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        144,
        176
      ],
      "id": "a4c9d4c3-630f-466e-9a6a-60d22144d1af",
      "name": "Merge"
    },
    {
      "parameters": {
        "operation": "xlsx",
        "options": {}
      },
      "type": "n8n-nodes-base.convertToFile",
      "typeVersion": 1.1,
      "position": [
        976,
        176
      ],
      "id": "80d5fc59-2fff-4542-b728-a6b3c2309bdc",
      "name": "Convert to File"
    },
    {
      "parameters": {
        "fieldToSplitOut": "results",
        "options": {}
      },
      "type": "n8n-nodes-base.splitOut",
      "typeVersion": 1,
      "position": [
        816,
        176
      ],
      "id": "7dd3fcd2-c5b7-4809-8f80-5187c645c79a",
      "name": "Split Out"
    },
    {
      "parameters": {
        "jsCode": "// n8n Function node\n// Merges multiple JSON inputs and deduplicates by \"id\"\n\nlet merged = [];\n\n// Collect all results arrays from inputs\nfor (const item of items) {\n  if (item.json.results && Array.isArray(item.json.results)) {\n    merged.push(...item.json.results);\n  }\n}\n\n// Deduplicate by \"id\"\nconst seen = new Set();\nconst deduped = merged.filter(entry => {\n  if (seen.has(entry.id)) {\n    return false;\n  }\n  seen.add(entry.id);\n  return true;\n});\n\n// Return single combined output\nreturn [\n  {\n    json: {\n      total: deduped.length,\n      results: deduped\n    }\n  }\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        368,
        176
      ],
      "id": "95042e8e-ee63-4253-a030-f3a15d06d9f5",
      "name": "SuperMerge"
    },
    {
      "parameters": {
        "jsCode": "// n8n Function node â€” SLA calculation using $input (avoids 'items' linter errors)\n// Paste into a Function node. Returns one output item per ticket: { json: { ... } }\n\n// === CONFIG ===\nconst DEFAULT_SLA_FIRST_RESPONSE_HOURS = 48; // change if needed\nconst DEFAULT_SLA_RESOLUTION_HOURS = 1000;   // change if needed\n\n\n// time_to_first_agent_reply - current definition of the Time to First Agent Reply is defined as time between create time to first reply time\n\n// If true, and hs_time_to_first_agent_reply is missing, use hs_lastmodifieddate/updatedAt as a fallback\nconst FALLBACK_USE_LAST_MODIFIED_AS_FIRST_RESPONSE = true;\n\n// === helpers ===\nfunction parseTimestamp(v) {\n  if (v === undefined || v === null || v === '') return null;\n  if (typeof v === 'number') {\n    // heuristic: large numbers are ms\n    if (v > 1e11) return new Date(v);\n    return new Date(v * 1000);\n  }\n  if (typeof v === 'string') {\n    if (/^\\d+$/.test(v)) return parseTimestamp(Number(v));\n    const d = new Date(v);\n    if (!isNaN(d.getTime())) return d;\n    return null;\n  }\n  return null;\n}\nfunction msToHours(ms) {\n  return ms == null ? null : ms / (1000 * 60 * 60);\n}\nfunction round4(n) {\n  return n == null ? null : Number(n.toFixed(4));\n}\nfunction getProp(o, key) {\n  if (!o) return undefined;\n  if (o.properties && o.properties[key] !== undefined) return o.properties[key];\n  if (o[key] !== undefined) return o[key];\n  return undefined;\n}\n\n// Use n8n $input helper to get incoming items (linter-friendly)\nconst incoming = $input.all(); // array of { json:, binary: }\n\n// === normalize input (support multiple possible paste shapes) ===\nlet rawTickets = [];\nif (incoming.length === 1) {\n  const firstJson = incoming[0].json;\n  if (Array.isArray(firstJson) && firstJson.length > 0 && Array.isArray(firstJson[0].results)) {\n    // shape: [ { total, results: [...] } ]\n    rawTickets = firstJson[0].results;\n  } else if (firstJson && Array.isArray(firstJson.results)) {\n    // shape: { total, results: [...] }\n    rawTickets = firstJson.results;\n  } else if (Array.isArray(firstJson)) {\n    // shape: [ { id, properties... }, ... ]\n    rawTickets = firstJson;\n  } else {\n    // fallback: treat each incoming item as a ticket (single item per input)\n    rawTickets = incoming.map(i => i.json);\n  }\n} else {\n  rawTickets = incoming.map(i => i.json);\n}\n\n// === process tickets ===\nconst output = rawTickets.map(ticket => {\n  // ids & subject\n  const ticketId = ticket.id ?? ticket.properties?.hs_object_id ?? ticket.properties?.hs_object_id ?? null;\n  const subject = getProp(ticket, 'subject') ?? ticket.title ?? null;\n\n  // created / closed\n  const createdRaw = getProp(ticket, 'createdate') ?? ticket.createdAt ?? ticket.created_at ?? ticket.created;\n  const createdAt = parseTimestamp(createdRaw);\n\n  const closedRaw = getProp(ticket, 'closed_date') ?? ticket.closedAt ?? ticket.closed_at ?? ticket.closed;\n  const closedAt = parseTimestamp(closedRaw);\n\n  // built-in ms fields (HubSpot sometimes gives ms, sometimes numeric-string)\n  \n  \n  const rawFirstMs = getProp(ticket, 'time_to_first_agent_reply') ;\n \n  \n  \n  \n  \n  const rawCloseMs = getProp(ticket, 'time_to_close') ;\n // console.log('DEBUG 000');\n // console.log(rawFirstMs);\n // console.log('DEBUG 001');\n // console.log(Number(rawFirstMs));\n // console.log('DEBUG 002');\n  \n  \n  \n  const firstMs = rawFirstMs ? Number(rawFirstMs) : null;\n  const closeMs = rawCloseMs ? Number(rawCloseMs) : null;\n  //console.log(firstMs);\n // console.log('DEBUG 003');\n  // compute durations (hours)\n  let timeToFirstHours = firstMs ? msToHours(firstMs) : null;\n\n\n\n  \n // console.log(timeToFirstHours);\n // console.log('DEBUG END');\n  let timeToCloseHours = closeMs ? msToHours(closeMs) : null;\n\n  // fallback: compute timeToFirst using last modified / updated if enabled\n  if (!timeToFirstHours && FALLBACK_USE_LAST_MODIFIED_AS_FIRST_RESPONSE && createdAt) {\n    const lastModRaw = getProp(ticket, 'hs_lastmodifieddate') ?? ticket.updatedAt ?? ticket.updated_at;\n    const lastMod = parseTimestamp(lastModRaw);\n\n    const lastModgetTime = lastMod.getTime();\n\n    const createdAtgetTime = createdAt.getTime();\n    \n    if (lastMod) {\n      timeToFirstHours = msToHours(lastModgetTime - createdAtgetTime);\n\n  //console.log('DEBUG 000');\n     // console.log(lastMod);\n  //console.log(msToHours(lastModgetTime));\n // console.log('DEBUG 001');\n    //  console.log(createdAt);\n//  console.log(msToHours(createdAtgetTime));\n // console.log('DEBUG 002');\n\n\n      \n    }\n  }\n\n    \n\n\n  // fallback: compute timeToClose from createdAt/closedAt when hs_time_to_close is missing\n  if (timeToCloseHours == null && createdAt && closedAt) {\n    timeToCloseHours = msToHours(closedAt.getTime() - createdAt.getTime());\n  }\n\n  // per-ticket SLA override (optional): ticket.sla = { firstResponseHours, resolutionHours }\n\n  \n  //const SLA_FIRST_HOURS = (ticket.sla && ticket.sla.firstResponseHours) ? Number(ticket.sla.firstResponseHours) : DEFAULT_SLA_FIRST_RESPONSE_HOURS;\n  //const SLA_RES_HOURS = (ticket.sla && ticket.sla.resolutionHours) ? Number(ticket.sla.resolutionHours) : DEFAULT_SLA_RESOLUTION_HOURS;\n\n\n   // reasons\n  const breachReasons = [];\n  const warnings = [];\n\n  const professionalServices = [];\n\n\n\n  const firstResponseMet = ((timeToFirstHours != null)) ? ((timeToFirstHours <= DEFAULT_SLA_FIRST_RESPONSE_HOURS)) : false;\n // const resolutionMet = (timeToCloseHours != null) ? (timeToCloseHours <= SLA_RES_HOURS) : true;\n\n \n/*  \n  if (timeToFirstHours == null) {breachReasons.push('missing_first_response_time');}\n  else if (!firstResponseMet) {\n    if(timeToFirstHours!=timeToCloseHours)  \n        breachReasons.push('first_response_breached');\n    else{warnings.push('anomolous');}\n  \n  \n  }\n*/\n  \n  //if (timeToCloseHours == null) breachReasons.push('missing_resolution_time');\n  //else if (!resolutionMet) breachReasons.push('resolution_breached');\n\n  \n\n  //if (timeToCloseHours == null) warnings.push('missing_resolution_time');\n\n  //if (!resolutionMet) warnings.push('closure_time_warning');\n\n if ( Math.trunc(timeToFirstHours)===Math.trunc(timeToCloseHours)){\n\n     //something went wrong\n     warnings.push('anomalous');\n   \n   \n   \n } else if(timeToFirstHours>DEFAULT_SLA_FIRST_RESPONSE_HOURS)\n \n {\n\n   breachReasons.push('first_response_breached');\n   \n }\n\n  if (timeToCloseHours>DEFAULT_SLA_RESOLUTION_HOURS){\n\n     warnings.push('long_closure_time');\n  }\n\n  const slaStatus = breachReasons.length === 0 ? 'Met' : 'Breached';\n\n  return {\n    json: {\n     // ticketId,\n      subject,\n\n      \n     //createdAt: createdAt ? createdAt.toISOString() : null,\n     //closedAt: closedAt ? closedAt.toISOString() : null,\n\n\n    createdAt: createdAt ? createdAt.toDateString() : null,\n    closedAt: closedAt ? closedAt.toDateString() : null,\n\n\n      \n    //  timeToFirstHours: round4(timeToFirstHours),\n      timeToFirstReadable: timeToFirstHours == null ? null : `${Math.floor(timeToFirstHours)}h ${Math.round((timeToFirstHours % 1) * 60)}m`,\n    //  timeToCloseHours: round4(timeToCloseHours),\n      timeToCloseReadable: timeToCloseHours == null ? null : `${Math.floor(timeToCloseHours)}h ${Math.round((timeToCloseHours % 1) * 60)}m`,\n      firstResponseMet,\n   //   resolutionMet,\n   //   SLA_firstHours: SLA_FIRST_HOURS,\n   //   SLA_resolutionHours: SLA_RES_HOURS,\n      professionalServices,\n      slaStatus,\n\n      breachReasons,\n      warnings\n     // raw: ticket // include raw ticket for debugging if desired\n     \n    }\n  };\n});\n\n// n8n expects an array of items back\n//return {\"results\":{output} };\n//const output2 = output.map(() => {\n // json:\"results\":{});\n//});\n  \nreturn  { \"results\": output } ;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        592,
        176
      ],
      "id": "86f3e79a-3214-4f83-8f69-4cbb6f49a8e7",
      "name": "SLA_Logic"
    },
    {
      "parameters": {
        "command": "python /home/chris/src/Xl2PPT/xl2ppt.py"
      },
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [
        704,
        448
      ],
      "id": "bff8c35d-ccfb-4e11-baf4-f320c33b1adc",
      "name": "Execute Command",
      "disabled": true
    }
  ],
  "pinData": {},
  "connections": {
    "Start": {
      "main": [
        [
          {
            "node": "HTTP Request1",
            "type": "main",
            "index": 0
          },
          {
            "node": "HTTP Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "HTTP Request1": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge": {
      "main": [
        [
          {
            "node": "SuperMerge",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split Out": {
      "main": [
        [
          {
            "node": "Convert to File",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "SuperMerge": {
      "main": [
        [
          {
            "node": "SLA_Logic",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "SLA_Logic": {
      "main": [
        [
          {
            "node": "Split Out",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "dd0c892d-5f82-4027-9a6a-44c24ed788cc",
  "meta": {
    "instanceId": "1e4bdd395bd9a43ad9c67815e4bae6c3a7b056eabe93685749ec3add43e2c23b"
  },
  "id": "n8PRxW7gpXfKQVUz",
  "tags": []
}
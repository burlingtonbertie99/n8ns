{
  "name": "Lloyds2",
  "nodes": [
    {
      "parameters": {
        "inputSource": "passthrough"
      },
      "id": "80ce68ec-5c16-42a6-b66e-e6cf0f8c07ad",
      "typeVersion": 1.1,
      "name": "Start",
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "position": [
        -336,
        288
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.hubapi.com/crm/v3/objects/tickets/search",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "hubspotAppToken",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "{\n  \"filterGroups\": [\n    {\n      \"filters\": [\n        {\n          \"propertyName\": \"associations.company\",\n          \"operator\": \"EQ\",\n          \"value\": 62873106\n        },\n        {\n          \"propertyName\": \"createdate\",\n          \"operator\": \"GTE\",\n          \"value\": \"2025-06-01T00:00:00Z\"\n        }\n      ]\n    }\n  ],\n  \"sorts\": [\n    { \"propertyName\": \"createdate\", \"direction\": \"ASCENDING\" }\n  ],\n  \"properties\": [\n    \"subject\",    \n    \"createdate\",    \n    \"closed_date\",\n    \"hs_time_to_first_agent_reply\",\n    \"hs_time_to_close\",\n    \"hs_pipeline_stage\"\n  ],\n  \"limit\": 100\n}\n",
        "options": {
          "allowUnauthorizedCerts": true
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -160,
        144
      ],
      "id": "b8e88321-2ce4-401e-b924-997b96a732ef",
      "name": "HTTP Request1",
      "credentials": {
        "hubspotAppToken": {
          "id": "5mZJoVAI8fTsYV0e",
          "name": "HubSpot account"
        }
      }
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.hubapi.com/crm/v3/objects/tickets/search",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "hubspotAppToken",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "{\n  \"filterGroups\": [\n    {\n      \"filters\": [\n        {\n          \"propertyName\": \"associations.company\",\n          \"operator\": \"EQ\",\n          \"value\": 62873106\n        },\n        {\n          \"propertyName\": \"hs_pipeline_stage\",\n          \"operator\": \"NEQ\",\n          \"value\": 4\n        }\n      ]\n    }\n  ],\n  \"sorts\": [\n    { \"propertyName\": \"createdate\", \"direction\": \"ASCENDING\" }\n  ],\n  \"properties\": [\n    \"subject\",    \n    \"createdate\", \n    \"closed_date\",\n    \"hs_time_to_first_agent_reply\",\n    \"hs_time_to_close\",\n    \"hs_pipeline_stage\"\n  ],\n  \"limit\": 100\n}\n",
        "options": {
          "allowUnauthorizedCerts": true
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -176,
        432
      ],
      "id": "08f8fafc-4a57-47eb-919e-a6051e40d6a5",
      "name": "HTTP Request",
      "credentials": {
        "hubspotAppToken": {
          "id": "5mZJoVAI8fTsYV0e",
          "name": "HubSpot account"
        }
      }
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        96,
        288
      ],
      "id": "8464b74b-ad77-420d-abce-90a5488fd796",
      "name": "Merge"
    },
    {
      "parameters": {
        "options": {
          "delimiter": ","
        }
      },
      "type": "n8n-nodes-base.convertToFile",
      "typeVersion": 1.1,
      "position": [
        576,
        288
      ],
      "id": "76e7bae5-9330-40db-8f4a-2147cb9a8060",
      "name": "Convert to File"
    },
    {
      "parameters": {
        "fieldToSplitOut": "results",
        "options": {}
      },
      "type": "n8n-nodes-base.splitOut",
      "typeVersion": 1,
      "position": [
        448,
        288
      ],
      "id": "73f61e97-891c-4d9d-9cce-1b318bfe15aa",
      "name": "Split Out"
    },
    {
      "parameters": {
        "jsCode": "// n8n Function node â€” SLA calculation tuned for your sample JSON\n// - Handles input shapes like: [{ total: X, results: [ { id, properties: {...}, createdAt, updatedAt } ] }]\n// - Produces one output item per ticket with slaStatus and breachReasons\n\n// === CONFIG ===\nconst DEFAULT_SLA_FIRST_RESPONSE_HOURS = 80; // change if needed\nconst DEFAULT_SLA_RESOLUTION_HOURS = 240;   // change if needed\n\n// If true, and hs_time_to_first_agent_reply is missing, this will (optionally)\n// use the ticket.updatedAt/hs_lastmodifieddate as a fallback approximation for\n// \"first response\". Set to true if your portal's lastmodified reliably means agent reply.\nconst FALLBACK_USE_LAST_MODIFIED_AS_FIRST_RESPONSE = true;\n\n// === helpers ===\nfunction parseTimestamp(v) {\n  if (v === undefined || v === null || v === '') return null;\n  if (typeof v === 'number') {\n    // heuristic: large numbers are ms\n    if (v > 1e11) return new Date(v);\n    return new Date(v * 1000);\n  }\n  if (typeof v === 'string') {\n    // numeric string?\n    if (/^\\d+$/.test(v)) {\n      return parseTimestamp(Number(v));\n    }\n    const d = new Date(v);\n    if (!isNaN(d.getTime())) return d;\n    return null;\n  }\n  return null;\n}\nfunction msToHours(ms) {\n  return ms == null ? null : ms / (1000 * 60 * 60);\n}\nfunction round4(n) {\n  return n == null ? null : Number(n.toFixed(4));\n}\nfunction getProp(o, key) {\n  if (!o) return undefined;\n  if (o.properties && o.properties[key] !== undefined) return o.properties[key];\n  if (o[key] !== undefined) return o[key];\n  return undefined;\n}\n\n// === normalize input (support multiple possible paste shapes) ===\nlet rawTickets = [];\nconst firstInput = items[0] && items[0].json;\n\nif (items.length === 1) {\n  // cases we expect from your paste:\n  // 1) items[0].json is an array whose first element has .results => [ { total, results: [...] } ]\n  // 2) items[0].json is an object with .results array\n  // 3) items[0].json is directly an array of ticket objects\n  if (Array.isArray(firstInput) && firstInput.length > 0 && Array.isArray(firstInput[0].results)) {\n    rawTickets = firstInput[0].results;\n  } else if (firstInput && Array.isArray(firstInput.results)) {\n    rawTickets = firstInput.results;\n  } else if (Array.isArray(firstInput)) {\n    rawTickets = firstInput;\n  } else {\n    // fallback: treat each incoming item as a ticket\n    rawTickets = items.map(i => i.json);\n  }\n} else {\n  rawTickets = items.map(i => i.json);\n}\n\n// === process ===\nconst output = rawTickets.map(ticket => {\n  // IDs & subject\n  const ticketId = ticket.id ?? ticket.properties?.hs_object_id ?? ticket.properties?.hs_object_id ?? null;\n  const subject = getProp(ticket, 'subject') ?? ticket.title ?? null;\n\n  // created / closed\n  const createdRaw = getProp(ticket, 'createdate') ?? ticket.createdAt ?? ticket.created_at ?? ticket.created;\n  const createdAt = parseTimestamp(createdRaw);\n\n  const closedRaw = getProp(ticket, 'closed_date') ?? ticket.closedAt ?? ticket.closed_at ?? ticket.closed;\n  const closedAt = parseTimestamp(closedRaw);\n\n  // built-in ms fields (HubSpot sometimes gives ms, sometimes numeric-string)\n  const rawFirstMs = getProp(ticket, 'hs_time_to_first_agent_reply') ?? getProp(ticket, 'hs_time_to_first_reply') ?? ticket.hs_time_to_first_agent_reply;\n  const rawCloseMs = getProp(ticket, 'hs_time_to_close') ?? ticket.hs_time_to_close;\n\n  const firstMs = rawFirstMs ? Number(rawFirstMs) : null;\n  const closeMs = rawCloseMs ? Number(rawCloseMs) : null;\n\n  // compute durations (hours)\n  let timeToFirstHours = firstMs ? msToHours(firstMs) : null;\n  let timeToCloseHours = closeMs ? msToHours(closeMs) : null;\n\n  // fallback: compute timeToFirst using last modified / updated if enabled\n  if (!timeToFirstHours && FALLBACK_USE_LAST_MODIFIED_AS_FIRST_RESPONSE && createdAt) {\n    const lastModRaw = getProp(ticket, 'hs_lastmodifieddate') ?? ticket.updatedAt ?? ticket.updated_at;\n    const lastMod = parseTimestamp(lastModRaw);\n    if (lastMod) {\n      timeToFirstHours = msToHours(lastMod.getTime() - createdAt.getTime());\n    }\n  }\n\n  // fallback: compute timeToClose from createdAt/closedAt when hs_time_to_close is missing\n  if (timeToCloseHours == null && createdAt && closedAt) {\n    timeToCloseHours = msToHours(closedAt.getTime() - createdAt.getTime());\n  }\n\n  // per-ticket SLA override (optional): ticket.sla = { firstResponseHours, resolutionHours }\n  const SLA_FIRST_HOURS = (ticket.sla && ticket.sla.firstResponseHours) ? Number(ticket.sla.firstResponseHours) : DEFAULT_SLA_FIRST_RESPONSE_HOURS;\n  const SLA_RES_HOURS = (ticket.sla && ticket.sla.resolutionHours) ? Number(ticket.sla.resolutionHours) : DEFAULT_SLA_RESOLUTION_HOURS;\n\n  const firstResponseMet = (timeToFirstHours != null) ? (timeToFirstHours <= SLA_FIRST_HOURS) : false;\n  const resolutionMet = (timeToCloseHours != null) ? (timeToCloseHours <= SLA_RES_HOURS) : false;\n\n  // reasons\n  const breachReasons = [];\n  if (timeToFirstHours == null) breachReasons.push('missing_first_response_time');\n  else if (!firstResponseMet) breachReasons.push('first_response_breached');\n\n  if (timeToCloseHours == null) breachReasons.push('missing_resolution_time');\n  else if (!resolutionMet) breachReasons.push('resolution_breached');\n\n  const slaStatus = breachReasons.length === 0 ? 'Met' : 'Breached';\n\n  return {\n    json: {\n      ticketId,\n      subject,\n      createdAt: createdAt ? createdAt.toISOString() : null,\n      closedAt: closedAt ? closedAt.toISOString() : null,\n      timeToFirstHours: round4(timeToFirstHours),\n      timeToFirstReadable: timeToFirstHours == null ? null : `${Math.floor(timeToFirstHours)}h ${Math.round((timeToFirstHours%1)*60)}m`,\n      timeToCloseHours: round4(timeToCloseHours),\n      timeToCloseReadable: timeToCloseHours == null ? null : `${Math.floor(timeToCloseHours)}h ${Math.round((timeToCloseHours%1)*60)}m`,\n      firstResponseMet,\n      resolutionMet,\n      SLA_firstHours: SLA_FIRST_HOURS,\n      SLA_resolutionHours: SLA_RES_HOURS,\n      breachReasons,\n      slaStatus,\n      raw: ticket // include raw ticket for debugging if you need it\n    }\n  };\n});\n\nreturn output;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        48,
        496
      ],
      "id": "f1995758-335d-4142-8086-a52f5c5e9bea",
      "name": "Code in JavaScript",
      "disabled": true
    },
    {
      "parameters": {
        "jsCode": "// n8n Function node\n// Merges multiple JSON inputs and deduplicates by \"id\"\n\nlet merged = [];\n\n// Collect all results arrays from inputs\nfor (const item of items) {\n  if (item.json.results && Array.isArray(item.json.results)) {\n    merged.push(...item.json.results);\n  }\n}\n\n// Deduplicate by \"id\"\nconst seen = new Set();\nconst deduped = merged.filter(entry => {\n  if (seen.has(entry.id)) {\n    return false;\n  }\n  seen.add(entry.id);\n  return true;\n});\n\n// Return single combined output\nreturn [\n  {\n    json: {\n      total: deduped.length,\n      results: deduped\n    }\n  }\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        256,
        304
      ],
      "id": "a7986d1e-da7a-4da7-888f-d7eb28cc01cb",
      "name": "SuperMerge"
    },
    {
      "parameters": {
        "jsCode": "// n8n Function node â€” SLA calculation using $input (avoids 'items' linter errors)\n// Paste into a Function node. Returns one output item per ticket: { json: { ... } }\n\n// === CONFIG ===\nconst DEFAULT_SLA_FIRST_RESPONSE_HOURS = 48; // change if needed\nconst DEFAULT_SLA_RESOLUTION_HOURS = 1000;   // change if needed\n\n// If true, and hs_time_to_first_agent_reply is missing, use hs_lastmodifieddate/updatedAt as a fallback\nconst FALLBACK_USE_LAST_MODIFIED_AS_FIRST_RESPONSE = true;\n\n// === helpers ===\nfunction parseTimestamp(v) {\n  if (v === undefined || v === null || v === '') return null;\n  if (typeof v === 'number') {\n    // heuristic: large numbers are ms\n    if (v > 1e11) return new Date(v);\n    return new Date(v * 1000);\n  }\n  if (typeof v === 'string') {\n    if (/^\\d+$/.test(v)) return parseTimestamp(Number(v));\n    const d = new Date(v);\n    if (!isNaN(d.getTime())) return d;\n    return null;\n  }\n  return null;\n}\nfunction msToHours(ms) {\n  return ms == null ? null : ms / (1000 * 60 * 60);\n}\nfunction round4(n) {\n  return n == null ? null : Number(n.toFixed(4));\n}\nfunction getProp(o, key) {\n  if (!o) return undefined;\n  if (o.properties && o.properties[key] !== undefined) return o.properties[key];\n  if (o[key] !== undefined) return o[key];\n  return undefined;\n}\n\n// Use n8n $input helper to get incoming items (linter-friendly)\nconst incoming = $input.all(); // array of { json:, binary: }\n\n// === normalize input (support multiple possible paste shapes) ===\nlet rawTickets = [];\nif (incoming.length === 1) {\n  const firstJson = incoming[0].json;\n  if (Array.isArray(firstJson) && firstJson.length > 0 && Array.isArray(firstJson[0].results)) {\n    // shape: [ { total, results: [...] } ]\n    rawTickets = firstJson[0].results;\n  } else if (firstJson && Array.isArray(firstJson.results)) {\n    // shape: { total, results: [...] }\n    rawTickets = firstJson.results;\n  } else if (Array.isArray(firstJson)) {\n    // shape: [ { id, properties... }, ... ]\n    rawTickets = firstJson;\n  } else {\n    // fallback: treat each incoming item as a ticket (single item per input)\n    rawTickets = incoming.map(i => i.json);\n  }\n} else {\n  rawTickets = incoming.map(i => i.json);\n}\n\n// === process tickets ===\nconst output = rawTickets.map(ticket => {\n  // ids & subject\n  const ticketId = ticket.id ?? ticket.properties?.hs_object_id ?? ticket.properties?.hs_object_id ?? null;\n  const subject = getProp(ticket, 'subject') ?? ticket.title ?? null;\n\n  // created / closed\n  const createdRaw = getProp(ticket, 'createdate') ?? ticket.createdAt ?? ticket.created_at ?? ticket.created;\n  const createdAt = parseTimestamp(createdRaw);\n\n  const closedRaw = getProp(ticket, 'closed_date') ?? ticket.closedAt ?? ticket.closed_at ?? ticket.closed;\n  const closedAt = parseTimestamp(closedRaw);\n\n  // built-in ms fields (HubSpot sometimes gives ms, sometimes numeric-string)\n  const rawFirstMs = getProp(ticket, 'hs_time_to_first_agent_reply') ?? getProp(ticket, 'hs_time_to_first_reply') ?? ticket.hs_time_to_first_agent_reply;\n  const rawCloseMs = getProp(ticket, 'hs_time_to_close') ?? ticket.hs_time_to_close;\n // console.log('DEBUG 000');\n // console.log(rawFirstMs);\n // console.log('DEBUG 001');\n // console.log(Number(rawFirstMs));\n // console.log('DEBUG 002');\n  const firstMs = rawFirstMs ? Number(rawFirstMs) : null;\n  const closeMs = rawCloseMs ? Number(rawCloseMs) : null;\n  //console.log(firstMs);\n // console.log('DEBUG 003');\n  // compute durations (hours)\n  let timeToFirstHours = firstMs ? msToHours(firstMs) : null;\n  console.log(timeToFirstHours);\n  console.log('DEBUG END');\n  let timeToCloseHours = closeMs ? msToHours(closeMs) : null;\n\n  // fallback: compute timeToFirst using last modified / updated if enabled\n  if (!timeToFirstHours && FALLBACK_USE_LAST_MODIFIED_AS_FIRST_RESPONSE && createdAt) {\n    const lastModRaw = getProp(ticket, 'hs_lastmodifieddate') ?? ticket.updatedAt ?? ticket.updated_at;\n    const lastMod = parseTimestamp(lastModRaw);\n\n    const lastModgetTime = lastMod.getTime();\n\n    const createdAtgetTime = createdAt.getTime();\n    \n    if (lastMod) {\n      timeToFirstHours = msToHours(lastModgetTime - createdAtgetTime);\n\n  console.log('DEBUG 000');\n      console.log(lastMod);\n  console.log(msToHours(lastModgetTime));\n  console.log('DEBUG 001');\n      console.log(createdAt);\n  console.log(msToHours(createdAtgetTime));\n // console.log('DEBUG 002');\n\n\n      \n    }\n  }\n\n    \n\n\n  // fallback: compute timeToClose from createdAt/closedAt when hs_time_to_close is missing\n  if (timeToCloseHours == null && createdAt && closedAt) {\n    timeToCloseHours = msToHours(closedAt.getTime() - createdAt.getTime());\n  }\n\n  // per-ticket SLA override (optional): ticket.sla = { firstResponseHours, resolutionHours }\n  const SLA_FIRST_HOURS = (ticket.sla && ticket.sla.firstResponseHours) ? Number(ticket.sla.firstResponseHours) : DEFAULT_SLA_FIRST_RESPONSE_HOURS;\n  const SLA_RES_HOURS = (ticket.sla && ticket.sla.resolutionHours) ? Number(ticket.sla.resolutionHours) : DEFAULT_SLA_RESOLUTION_HOURS;\n\n  const firstResponseMet = (timeToFirstHours != null) ? (timeToFirstHours <= SLA_FIRST_HOURS) : false;\n  const resolutionMet = (timeToCloseHours != null) ? (timeToCloseHours <= SLA_RES_HOURS) : false;\n\n  // reasons\n  const breachReasons = [];\n  if (timeToFirstHours == null) breachReasons.push('missing_first_response_time');\n  else if (!firstResponseMet) breachReasons.push('first_response_breached');\n\n  if (timeToCloseHours == null) breachReasons.push('missing_resolution_time');\n  else if (!resolutionMet) breachReasons.push('resolution_breached');\n\n  const slaStatus = breachReasons.length === 0 ? 'Met' : 'Breached';\n\n  return {\n    json: {\n      ticketId,\n      subject,\n      createdAt: createdAt ? createdAt.toISOString() : null,\n      closedAt: closedAt ? closedAt.toISOString() : null,\n      timeToFirstHours: round4(timeToFirstHours),\n      timeToFirstReadable: timeToFirstHours == null ? null : `${Math.floor(timeToFirstHours)}h ${Math.round((timeToFirstHours % 1) * 60)}m`,\n      timeToCloseHours: round4(timeToCloseHours),\n      timeToCloseReadable: timeToCloseHours == null ? null : `${Math.floor(timeToCloseHours)}h ${Math.round((timeToCloseHours % 1) * 60)}m`,\n      firstResponseMet,\n      resolutionMet,\n      SLA_firstHours: SLA_FIRST_HOURS,\n      SLA_resolutionHours: SLA_RES_HOURS,\n      breachReasons,\n      slaStatus,\n      raw: ticket // include raw ticket for debugging if desired\n    }\n  };\n});\n\n// n8n expects an array of items back\nreturn output;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        400,
        128
      ],
      "id": "d93fb52e-338c-4d48-9ede-e7046e390330",
      "name": "SLA_Logic"
    }
  ],
  "pinData": {},
  "connections": {
    "Start": {
      "main": [
        [
          {
            "node": "HTTP Request1",
            "type": "main",
            "index": 0
          },
          {
            "node": "HTTP Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 1
          },
          {
            "node": "Code in JavaScript",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request1": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge": {
      "main": [
        [
          {
            "node": "SuperMerge",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split Out": {
      "main": [
        [
          {
            "node": "Convert to File",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "SuperMerge": {
      "main": [
        [
          {
            "node": "SLA_Logic",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "SLA_Logic": {
      "main": [
        [
          {
            "node": "Split Out",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "ff4de7aa-131e-48b7-9bae-3e66840e3504",
  "meta": {
    "instanceId": "9f907c92272889a5dc0ef92a24ccfcea3e297e5f5b082cb541436cfc36d76e19"
  },
  "id": "yiw1dKQenVrLZh6t",
  "tags": []
}